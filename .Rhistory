paste(1:3,c("X","Y","Z") sep="")
paste(1:3,c("X","Y","Z"), sep="")
paste(LETTERS, 1:4, sep="-")
x<-c(44,NA,5,NA)
x*3
y<-rnorm(1000)
z<-rep(NA,1000)
my_data<-sample(c(y,z),100)
my_na<-is.na(my_data)
my_na
my_data==NA
sum(my_na)
my_data
0/0
Inf-Inf
x
x[1:10]
x[is.na(x])]
x[is.na(x)]
y<-x[!is.na(x)]
y
y[y>0]
x[x>0]
x[!is.na(x) & x>0]
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect <- c(foo = 11,
| bar = 2, norf = NA)
vect <- c(foo = 11,bar = 2, norf = NA)
vect
names(vect)
vect2<-c(11,2,NA)
names(vect2)<-c("foo","bar","norf")
?identical
identical(vect,vect2)
vect["bar"]
vect[c("foo","bar")]
my_vector<- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector) <-c(4,5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
View(my_vector)
my_vector->my_matrix
?matrix
my_matrix2<- matrix(1:20, 4,5)
identical(my_matrix,my_matrix2)
patients<-c("Bill","Gina","Kelly","Sean")
cbind(patients,my_matrix)
my_data<-data.frame(patients, my_matrix)
my_data
class(my_data)
cnames<-c("patient","age","weight","bp","rating","test")
colnames(my_data) <- cnames
my_data
#Accept a square matrix that can have the inverse calculated - instructions explicitly state that I can
# assume this - therefore don't have to handle situations where this is not true
makeCacheMatrix <- function(x = matrix()) {   #input x will be a matrix
i <- NULL                             # reset i each time. i will be the inverse matrix
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x     # returns the value of first matrix
setinv <- function(solve) i <<- solve  #called by cachesolve on first run, and cache the value for i
getinv <- function() i                # return the cached value of i if it exists
list(set = set, get = get,            #list of the functions which can be used in cacheSolve
setinv = setinv,
getinv = getinv)
}
# compute the inverse of the matrix object returned by makeCacheMatrix above
# If the inverse has already been calculated then rtn the cached value and bypass the calculation phase
cacheSolve <- function(x, ...) {            # the input is an object created by makeCacheMatrix
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
makeCacheMatrix <- function(x = matrix()) {   #input x will be a matrix
i <- NULL                             # reset i each time. i will be the inverse matrix
# set <- function(y) {
#        x <<- y
#       i <<- NULL
#}
get <- function() x     # returns the value of first matrix
setinv <- function(solve) i <<- solve  #called by cachesolve on first run, and cache the value for i
getinv <- function() i                # return the cached value of i if it exists
list(set = set, get = get,            #list of the functions which can be used in cacheSolve
setinv = setinv,
getinv = getinv)
}
# compute the inverse of the matrix object returned by makeCacheMatrix above
# If the inverse has already been calculated then rtn the cached value and bypass the calculation phase
cacheSolve <- function(x, ...) {            # the input is an object created by makeCacheMatrix
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
#Accept a square matrix that can have the inverse calculated - instructions explicitly state that I can
# assume this - therefore don't have to handle situations where this is not true
makeCacheMatrix <- function(x = matrix()) {   #input x will be a matrix
i <- NULL                             # reset i each time. i will be the inverse matrix
# set <- function(y) {
#        x <<- y
#       i <<- NULL
#}
get <- function() x     # returns the value of first matrix
setinv <- function(solve) i <<- solve  #called by cachesolve on first run, and cache the value for i
getinv <- function() i                # return the cached value of i if it exists
list(get = get,            #list of the functions which can be used in cacheSolve
setinv = setinv,
getinv = getinv)
}
# compute the inverse of the matrix object returned by makeCacheMatrix above
# If the inverse has already been calculated then rtn the cached value and bypass the calculation phase
cacheSolve <- function(x, ...) {            # the input is an object created by makeCacheMatrix
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
mat <- matrix(rnorm(4),2,2)
# mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
mat <- matrix(1:4,2,2)
# mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
mat <- matrix(rnorm(4),2,2)
mat
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
#Accept a square matrix that can have the inverse calculated - instructions explicitly state that I can
# assume this - therefore don't have to handle situations where this is not true
makeCacheMatrix <- function(x = matrix()) {    #input x will be a matrix
i <- NULL                              # reset i each time. i will be the inverse matrix
get <- function() x                    # returns the value of first matrix
setinv <- function(solve) i <<- solve  #called by cachesolve on first run, and cache the value for i
getinv <- function() i                 # return the cached value of i if it exists
list(get = get,                        #list of the functions which can be used in cacheSolve
setinv = setinv,
getinv = getinv)
}
# compute the inverse of the matrix object returned by makeCacheMatrix above
# If the inverse has already been calculated then rtn the cached value and bypass the calculation phase
cacheSolve <- function(x, ...) {               # the input is an object created by makeCacheMatrix
i <- x$getinv()                        # accesses the object 'x' and gets the value of the inversion
if(!is.null(i)) {                      # if the i is not NULL, therefore it is cached
message("getting cached data") # retn. message to console
return(i)                      # retn. the cached value for i
}
data <- x$get()                        # assigns the value of matrix x to data
i <- solve(data, ...)                  # solves data and assigns to i
x$setinv(i)                            # uses setinv from makeCacheMatrix to cache the result using <<-
i                                      # prints the result to console
}
mat <- matrix(1:4,2,2)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
#Accept a square matrix that can have the inverse calculated - instructions explicitly state that I can
# assume this - therefore don't have to handle situations where this is not true
makeCacheMatrix <- function(x = matrix()) {    #input x will be a matrix
i <- NULL                              # reset i each time. i will be the inverse matrix
get <- function() x                    # returns the value of first matrix
setinv <- function(solve) i <<- solve  #called by cachesolve on first run, and cache the value for i
getinv <- function() i                 # return the cached value of i if it exists
list(get = get,                        #list of the functions which can be used in cacheSolve
setinv = setinv,
getinv = getinv)
}
# compute the inverse of the matrix object returned by makeCacheMatrix above
# If the inverse has already been calculated then rtn the cached value and bypass the calculation phase
cacheSolve <- function(x, ...) {               # the input is an object created by makeCacheMatrix
i <- x$getinv()                        # accesses the object 'x' and gets the value of the inversion
if(!is.null(i)) {                      # if the i is not NULL, therefore it is cached
message("getting cached data") # retn. message to console
return(i)                      # retn. the cached value for i
}
data <- x$get()                        # assigns the value of matrix x to data
i <- solve(data, ...)                  # solves data and assigns to i
x$setinv(i)                            # uses setinv from makeCacheMatrix to cache the result using <<-
i                                      # prints the result to console
}
mat <- matrix(rnorm(4),2,2)
#mat <- matrix(1:4,2,2)
#mat <- matrix(rnorm(100),10,10)
#mat <- matrix(rnorm(10000),100,100)
test <- makeCacheMatrix(mat)
cacheSolve(test)
cacheSolve(test)
library(swirl)
swirl()
library(dplyr)
cran <- tbl_df(mydf)
rm("mydf")
cran
?group_by
by_package <- group_by(cran, package)
by_package
summarize(by_package = mean(size))
summarize(by_package, mean(size))
?n
?n_distinct
submit()
submit()
reset()
mean(size) )
submit()
by_package
submit()
submit()
submit()
submit()
reset()
submit()
submit()
pack_sum
quantile(pack_sum$count, probs = 0.99)
filter(pack_sum, count > 679) -> top_counts
top_counts
head(top_counts, 20)
arrange(top_counts, desc(count))
quantile(pack_sum$unique, probs = 0.99)
filter(pack_sum, unique > 465) -> top_unique
top_unique
arrange(top_unique, desc(unique))
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
library(tidyr)
students
?gather
gather(students, sex, count, -grade)
students2
gather(students2, sex_class, count) -> res
gather(students2, sex_class, count, -grade) -> res
res
?separate
separate(res, sex_class, c("sex", "class"))
submit()
students3
submit()
?spread
submit()
submit()
submit()
submit()
extract_numeric("class5")
submit()
?mutate
submit()
submit()
submit()
print
students3 %>%
gather(class, grade, class1:class5, na.rm = TRUE) %>%
spread( test, grade ) %>%
print
submit()
?extract_numeric
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
students4
submit()
submit()
submit()
reset()
submit()
submit()
passed
failed
mutate(passed, passed = passed)
mutate(passed, passed = "passed")
passed <- passed %>% mutate(status = "passed")
failed <- failed %>% mutate(status = "failed")
?rbind_list
rbind_list(passed, failed)
sat
?separate
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
sat %>%
select(-contains("total")) %>%
gather(read_male, write_total, -score_range) %>%
separate(part_sex, c("part", "sex")) %>%
print
reset()
sat %>%
select(-contains(total)) %>%
print
sat %>%
select(-contains("total")) %>%
print
sat %>%
select(-contains("total")) %>%
gather(read_male, write_fem, -score_range) %>%
print
sat %>%
select(-contains("total")) %>%
gather(read_male, write_fem, -score_range) %>%
separate(read_male, c(part, sex)) %>%
print
sat %>%
select(-contains("total")) %>%
gather(read_male, write_fem, -score_range) %>%
separate(read_male, c("part", "sex")) %>%
print
submit()
submit()
sat %>%
select(-contains("total")) %>%
gather(read_male, -score_range) %>%
separate(read_male, c("part", "sex")) %>%
print
sat %>%
select(-contains("total")) %>%
gather(read_male, -score_range) %>%
print
sat
sat %>%
select(-contains("total")) %>%
gather(part_sex, count -score_range) %>%
separate(part_sex, c("part", "sex")) %>%
print
sat %>%
select(-contains("total")) %>%
gather(part_sex, count -score_range) %>%
print
?gather
sat %>%
select(-contains("total")) %>%
print
gather(part_sex, count -score_range) %>%
print
sat %>%
select(-contains("total")) %>%
gather(part_sex, count -score_range) %>%
print
sat %>%
select(-contains("total")) %>%
gather(part_sex, count, -score_range) %>%
print
submit()
submit()
submit()
Sys.getlocale("LC_TIME")
library(lubridate)
hrlp(package = lubridate)
help(package = lubridate)
this_day <- today()
this_day
year(this_day)
wday(this_day)
wday(this_day, label = TRUE)
now()
this_moment <- now()
this_moment
hour(this_moment)
ymd("1989-05-17")
mydate <- ymd("1989-05-17")
my_date <- ymd("1989-05-17")
my_date
class(my_date)
ymd("1989 May 17")
ymd("March 12, 1975")
mdy("March 12, 1975")
dmy("25081985")
dmy(25081985)
ymd("192012")
ymd("1920/1/2")
dt1
ymd_hms(dt1)
hms("03:22:14")
dt2
ymd(dt2)
update(this_moment, hours = 8, minutes = 34, seconds = 55)
this_moment
this_moment <- update(this_moment, hours = 23, minutes = 57, seconds = 55)
this_moment
nyc <- now("America/New_York")
nyc
nyc + days(2) ->depart
depart
depart <- update(depart, hours = 17, minutes = 34)
depart
arrive <- depart + hours(15), minutes(50)
arrive <- depart + hours(15) minutes(50)
arrive <- depart + (hours(15), minutes(50))
arrive <- update(depart + hours(15) minutes(50))
arrive <- update(depart + (hours(15) minutes(50)))
arrive <- depart + hours(15)
arrive <- depart + hours(15) + minutes(50)
?with_tz
with_tz(arrive, tzone = "Asia/Hong_Kong")
arrive <- with_tz(arrive, tzone = "Asia/Hong_Kong")
arrive
last_time <- mdy("June 17, 2008", tz = "Singapore")
last_time
?new_interval
how_long <- new_interval(last_time, arrive,)
as.period(how_long)
stopwatch()
x <- 1:4
p <- x/sum(x)
temp <- rbind(x, p)
rownames(temp) <- c("X", "Prob")
temp
mean(temp)
75*(1-52)
ans*.3
75/(1-52)
75/(1-52) -> as
as * .3
round(qnorm(.95, mean = 100, sd = 10 / sqrt(50) ), 3)
round(qnorm(.95, mean = 1100, sd = 75), 3)
round(qnorm(.95, mean = 1100, sd = 75 / sqrt(100) ), 3)
round(pbinom(4, prob = .5, size = 6, lower.tail = FALSE)
round(pbinom(4, prob = .5, size = 6, lower.tail = FALSE)
round(pbinom(4, prob = .5, size = 6, lower.tail = FALSE), 1)
round(pbinom(4, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(2, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(1, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(7, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(6, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(5, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(4, prob = .5, size = 6, lower.tail = FALSE), 3)
round(pbinom(4, prob = .5, size = 5, lower.tail = FALSE), 3)
round(pbinom(3, prob = .5, size = 5, lower.tail = FALSE), 3)
round(pbinom(4, prob = .5, size = 5, lower.tail = FALSE), 3)
round(pbinom(5, prob = .5, size = 5, lower.tail = FALSE), 3)
round(pbinom(5, prob = .5, size = 5, lower.tail = FALSE), 10)
round(pbinom(4.5, prob = .5, size = 5, lower.tail = FALSE), 10)
round(pnorm(.5, mean = 0.5, sd = sqrt(1 / 12 / 1000), lower.tail = FALSE), 3)
mean((-1 : 1 - 0)^2)
((-1 : 1 - 0)^2)
?aggregate
setwd("~/GitHub/datasciencecoursera/Reproducible/RepData_PeerAssessment1")
data <- read.csv("activity.csv")
y <- aggregate(data, date, mean, na.action = na.omit)
y <- aggregate(data,list =(date), mean, na.action = na.omit)
y <- aggregate(data,list =(date), FUN ="mean"", na.action = na.omit)
y <- aggregate(data,list =(date), FUN ="mean", na.action = na.omit)
y <- aggregate(data, by = list(date), FUN ="mean", na.action = na.omit)
